From c4f79fce431b52cc39ca5f5b0d83a3cb9166a8f7 Mon Sep 17 00:00:00 2001
From: xiaoyu <7547189+xytoki@users.noreply.github.com>
Date: Sat, 14 Feb 2026 04:47:43 +0000
Subject: [PATCH] xy-patch-latest

---
 cmd/tailscale/cli/set.go        |  9 ++++++
 cmd/tailscale/cli/up.go         | 12 ++++++++
 ipn/ipn_clone.go                |  3 ++
 ipn/ipn_view.go                 | 16 ++++++++++
 ipn/ipnlocal/local.go           | 26 ++++++++++++++++-
 ipn/prefs.go                    | 30 +++++++++++++++++++
 net/netcheck/netcheck.go        | 21 +++++++++----
 net/netmon/state.go             | 52 +++++++++++++++++++++++++++++++++
 net/tsaddr/tsaddr.go            | 16 ++++++++--
 types/netmap/netmap.go          |  6 ++++
 wgengine/magicsock/derp.go      | 23 +++++++++++++++
 wgengine/magicsock/magicsock.go | 21 +++++++++++++
 wgengine/wgcfg/nmcfg/nmcfg.go   | 24 +++++++++++++++
 13 files changed, 250 insertions(+), 9 deletions(-)

diff --git a/cmd/tailscale/cli/set.go b/cmd/tailscale/cli/set.go
index 615900833..a89f744c2 100644
--- a/cmd/tailscale/cli/set.go
+++ b/cmd/tailscale/cli/set.go
@@ -46,6 +46,9 @@
 
 type setArgsT struct {
 	acceptRoutes               bool
+	acceptLocalRoutes          bool
+	ignoreInterfaces           string
+	ignoreRoutes               string
 	acceptDNS                  bool
 	exitNodeIP                 string
 	exitNodeAllowLANAccess     bool
@@ -76,6 +79,9 @@ func newSetFlagSet(goos string, setArgs *setArgsT) *flag.FlagSet {
 
 	setf.StringVar(&setArgs.profileName, "nickname", "", "nickname for the current account")
 	setf.BoolVar(&setArgs.acceptRoutes, "accept-routes", acceptRouteDefault(goos), "accept routes advertised by other Tailscale nodes")
+	setf.BoolVar(&setArgs.acceptLocalRoutes, "accept-local-routes", false, "accept routes advertised by other Tailscale nodes even if they overlap with the local machine's routes")
+	setf.StringVar(&setArgs.ignoreInterfaces, "ignore-interfaces", "", "interface name prefixes to ignore when reporting local addresses (comma-separated, e.g. \"docker0,br-,veth\")")
+	setf.StringVar(&setArgs.ignoreRoutes, "ignore-routes", "", "CIDR routes to ignore from other nodes (comma-separated, e.g. \"10.0.0.0/8,192.168.1.0/24\")")
 	setf.BoolVar(&setArgs.acceptDNS, "accept-dns", true, "accept DNS configuration from the admin panel")
 	setf.StringVar(&setArgs.exitNodeIP, "exit-node", "", "Tailscale exit node (IP, base name, or auto:any) for internet traffic, or empty string to not use an exit node")
 	setf.BoolVar(&setArgs.exitNodeAllowLANAccess, "exit-node-allow-lan-access", false, "Allow direct access to the local network when routing traffic via an exit node")
@@ -146,6 +152,9 @@ func runSet(ctx context.Context, args []string) (retErr error) {
 		Prefs: ipn.Prefs{
 			ProfileName:            setArgs.profileName,
 			RouteAll:               setArgs.acceptRoutes,
+			RouteLocal:             setArgs.acceptLocalRoutes,
+			IgnoreInterfaces:       setArgs.ignoreInterfaces,
+			IgnoreRoutes:           setArgs.ignoreRoutes,
 			CorpDNS:                setArgs.acceptDNS,
 			ExitNodeAllowLANAccess: setArgs.exitNodeAllowLANAccess,
 			ShieldsUp:              setArgs.shieldsUp,
diff --git a/cmd/tailscale/cli/up.go b/cmd/tailscale/cli/up.go
index d78cb2d44..63bd65b4d 100644
--- a/cmd/tailscale/cli/up.go
+++ b/cmd/tailscale/cli/up.go
@@ -107,6 +107,7 @@ func newUpFlagSet(goos string, upArgs *upArgsT, cmd string) *flag.FlagSet {
 
 	upf.StringVar(&upArgs.server, "login-server", ipn.DefaultControlURL, "base URL of control server")
 	upf.BoolVar(&upArgs.acceptRoutes, "accept-routes", acceptRouteDefault(goos), "accept routes advertised by other Tailscale nodes")
+	upf.BoolVar(&upArgs.acceptLocalRoutes, "accept-local-routes", false, "accept routes advertised by other Tailscale nodes even if they overlap with the local machine's routes")
 	upf.BoolVar(&upArgs.acceptDNS, "accept-dns", true, "accept DNS configuration from the admin panel")
 	upf.Var(notFalseVar{}, "host-routes", hidden+"install host routes to other Tailscale nodes (must be true as of Tailscale 1.67+)")
 	upf.StringVar(&upArgs.exitNodeIP, "exit-node", "", "Tailscale exit node (IP, base name, or auto:any) for internet traffic, or empty string to not use an exit node")
@@ -179,6 +180,7 @@ type upArgsT struct {
 	reset                  bool
 	server                 string
 	acceptRoutes           bool
+	acceptLocalRoutes      bool
 	acceptDNS              bool
 	exitNodeIP             string
 	exitNodeAllowLANAccess bool
@@ -325,6 +327,7 @@ func prefsFromUpArgs(upArgs upArgsT, warnf logger.Logf, st *ipnstate.Status, goo
 	prefs.ControlURL = upArgs.server
 	prefs.WantRunning = true
 	prefs.RouteAll = upArgs.acceptRoutes
+	prefs.RouteLocal = upArgs.acceptLocalRoutes
 	if distro.Get() == distro.Synology {
 		// ipn.NewPrefs returns a non-zero Netfilter default. But Synology only
 		// supports "off" mode.
@@ -889,6 +892,9 @@ func init() {
 	// The rest are 1:1:
 	addPrefFlagMapping("accept-dns", "CorpDNS")
 	addPrefFlagMapping("accept-routes", "RouteAll")
+	addPrefFlagMapping("accept-local-routes", "RouteLocal")
+	addPrefFlagMapping("ignore-interfaces", "IgnoreInterfaces")
+	addPrefFlagMapping("ignore-routes", "IgnoreRoutes")
 	addPrefFlagMapping("advertise-tags", "AdvertiseTags")
 	addPrefFlagMapping("hostname", "Hostname")
 	addPrefFlagMapping("login-server", "ControlURL")
@@ -1145,6 +1151,12 @@ func prefsToFlags(env upCheckEnv, prefs *ipn.Prefs) (flagVal map[string]any) {
 			set(prefs.ControlURL)
 		case "accept-routes":
 			set(prefs.RouteAll)
+		case "accept-local-routes":
+			set(prefs.RouteLocal)
+		case "ignore-interfaces":
+			set(prefs.IgnoreInterfaces)
+		case "ignore-routes":
+			set(prefs.IgnoreRoutes)
 		case "accept-dns":
 			set(prefs.CorpDNS)
 		case "shields-up":
diff --git a/ipn/ipn_clone.go b/ipn/ipn_clone.go
index 94aebefdf..eaa108c29 100644
--- a/ipn/ipn_clone.go
+++ b/ipn/ipn_clone.go
@@ -73,6 +73,9 @@ func (src *Prefs) Clone() *Prefs {
 var _PrefsCloneNeedsRegeneration = Prefs(struct {
 	ControlURL                 string
 	RouteAll                   bool
+	RouteLocal                 bool
+	IgnoreInterfaces           string
+	IgnoreRoutes               string
 	ExitNodeID                 tailcfg.StableNodeID
 	ExitNodeIP                 netip.Addr
 	AutoExitNode               ExitNodeExpression
diff --git a/ipn/ipn_view.go b/ipn/ipn_view.go
index 90560cec0..bcda4f62b 100644
--- a/ipn/ipn_view.go
+++ b/ipn/ipn_view.go
@@ -233,6 +233,19 @@ func (v PrefsView) ControlURL() string { return v.ж.ControlURL }
 // controlled by ExitNodeID/IP below.
 func (v PrefsView) RouteAll() bool { return v.ж.RouteAll }
 
+// RouteLocal specifies whether to install a route if it includes
+// a local ip address. This is a temporary workaround.
+func (v PrefsView) RouteLocal() bool { return v.ж.RouteLocal }
+
+// IgnoreInterfaces is a comma-separated list of interface name prefixes
+// that should be ignored when reporting local addresses to the Tailscale
+// server.
+func (v PrefsView) IgnoreInterfaces() string { return v.ж.IgnoreInterfaces }
+
+// IgnoreRoutes is a comma-separated list of CIDR prefixes that should be
+// ignored when accepting routes advertised by other nodes.
+func (v PrefsView) IgnoreRoutes() string { return v.ж.IgnoreRoutes }
+
 // ExitNodeID and ExitNodeIP specify the node that should be used
 // as an exit node for internet traffic. At most one of these
 // should be non-zero.
@@ -475,6 +488,9 @@ func (v PrefsView) Persist() persist.PersistView { return v.ж.Persist.View() }
 var _PrefsViewNeedsRegeneration = Prefs(struct {
 	ControlURL                 string
 	RouteAll                   bool
+	RouteLocal                 bool
+	IgnoreInterfaces           string
+	IgnoreRoutes               string
 	ExitNodeID                 tailcfg.StableNodeID
 	ExitNodeIP                 netip.Addr
 	AutoExitNode               ExitNodeExpression
diff --git a/ipn/ipnlocal/local.go b/ipn/ipnlocal/local.go
index e9222cde3..e9ab1ce0f 100644
--- a/ipn/ipnlocal/local.go
+++ b/ipn/ipnlocal/local.go
@@ -5089,6 +5089,10 @@ func (b *LocalBackend) authReconfigLocked() {
 	}
 
 	prefs := b.pm.CurrentPrefs()
+
+	// Apply ignored interfaces setting
+	netmon.SetIgnoredInterfaces(prefs.IgnoreInterfaces())
+
 	hasPAC := b.interfaceState.HasPAC()
 	disableSubnetsIfPAC := cn.SelfHasCap(tailcfg.NodeAttrDisableSubnetsIfPAC)
 	dohURL, dohURLOK := cn.exitNodeCanProxyDNS(prefs.ExitNodeID())
@@ -5105,6 +5109,9 @@ func (b *LocalBackend) authReconfigLocked() {
 	if prefs.RouteAll() {
 		flags |= netmap.AllowSubnetRoutes
 	}
+	if prefs.RouteLocal() {
+		flags |= netmap.AllowLocalRoutes
+	}
 	if hasPAC && disableSubnetsIfPAC {
 		if flags&netmap.AllowSubnetRoutes != 0 {
 			b.logf("authReconfig: have PAC; disabling subnet routes")
@@ -5128,6 +5135,23 @@ func (b *LocalBackend) authReconfigLocked() {
 		priv = key.NodePrivate{}
 	}
 
+	// Parse and set IgnoreRoutes from preferences
+	if ignoreRoutesStr := prefs.IgnoreRoutes(); ignoreRoutesStr != "" {
+		var ignoreRoutes []netip.Prefix
+		for _, s := range strings.Split(ignoreRoutesStr, ",") {
+			s = strings.TrimSpace(s)
+			if s == "" {
+				continue
+			}
+			if p, err := netip.ParsePrefix(s); err == nil {
+				ignoreRoutes = append(ignoreRoutes, p)
+			} else {
+				b.logf("authReconfig: invalid ignore-routes prefix %q: %v", s, err)
+			}
+		}
+		nm.IgnoreRoutes = ignoreRoutes
+	}
+
 	cfg, err := nmcfg.WGCfg(priv, nm, b.logf, flags, prefs.ExitNodeID())
 	if err != nil {
 		b.logf("wgcfg: %v", err)
@@ -5141,7 +5165,7 @@ func (b *LocalBackend) authReconfigLocked() {
 	if err == wgengine.ErrNoChanges {
 		return
 	}
-	b.logf("[v1] authReconfig: ra=%v dns=%v 0x%02x: %v", prefs.RouteAll(), prefs.CorpDNS(), flags, err)
+	b.logf("[v1] authReconfig: ra=%v rl=%v dns=%v 0x%02x: %v", prefs.RouteAll(), prefs.RouteLocal(), prefs.CorpDNS(), flags, err)
 
 	b.initPeerAPIListenerLocked()
 	if buildfeatures.HasAppConnectors {
diff --git a/ipn/prefs.go b/ipn/prefs.go
index 72e0cf8b7..2879df550 100644
--- a/ipn/prefs.go
+++ b/ipn/prefs.go
@@ -79,6 +79,22 @@ type Prefs struct {
 	// controlled by ExitNodeID/IP below.
 	RouteAll bool
 
+	// RouteLocal specifies whether to install a route if it includes
+	// a local ip address. This is a temporary workaround.
+	RouteLocal bool
+
+	// IgnoreInterfaces is a comma-separated list of interface name prefixes
+	// that should be ignored when reporting local addresses to the Tailscale
+	// server. For example, "docker0,br-,veth" would ignore docker0, any
+	// interface starting with br-, and any interface starting with veth.
+	IgnoreInterfaces string
+
+	// IgnoreRoutes is a comma-separated list of CIDR prefixes that should be
+	// ignored when accepting routes advertised by other nodes. For example,
+	// "10.0.0.0/8,192.168.1.0/24" would ignore any routes that overlap with
+	// these prefixes even if accept-routes is enabled.
+	IgnoreRoutes string
+
 	// ExitNodeID and ExitNodeIP specify the node that should be used
 	// as an exit node for internet traffic. At most one of these
 	// should be non-zero.
@@ -355,6 +371,9 @@ type MaskedPrefs struct {
 
 	ControlURLSet                 bool                `json:",omitempty"`
 	RouteAllSet                   bool                `json:",omitempty"`
+	RouteLocalSet                 bool                `json:",omitempty"`
+	IgnoreInterfacesSet           bool                `json:",omitempty"`
+	IgnoreRoutesSet               bool                `json:",omitempty"`
 	ExitNodeIDSet                 bool                `json:",omitempty"`
 	ExitNodeIPSet                 bool                `json:",omitempty"`
 	AutoExitNodeSet               bool                `json:",omitempty"`
@@ -545,6 +564,13 @@ func (p *Prefs) pretty(goos string) string {
 	sb.WriteString("Prefs{")
 	if buildfeatures.HasUseRoutes {
 		fmt.Fprintf(&sb, "ra=%v ", p.RouteAll)
+		fmt.Fprintf(&sb, "rl=%v ", p.RouteLocal)
+	}
+	if p.IgnoreInterfaces != "" {
+		fmt.Fprintf(&sb, "ignore-ifaces=%q ", p.IgnoreInterfaces)
+	}
+	if p.IgnoreRoutes != "" {
+		fmt.Fprintf(&sb, "ignore-routes=%q ", p.IgnoreRoutes)
 	}
 	if buildfeatures.HasDNS {
 		fmt.Fprintf(&sb, "dns=%v want=%v ", p.CorpDNS, p.WantRunning)
@@ -663,6 +689,9 @@ func (p *Prefs) Equals(p2 *Prefs) bool {
 
 	return p.ControlURL == p2.ControlURL &&
 		p.RouteAll == p2.RouteAll &&
+		p.RouteLocal == p2.RouteLocal &&
+		p.IgnoreInterfaces == p2.IgnoreInterfaces &&
+		p.IgnoreRoutes == p2.IgnoreRoutes &&
 		p.ExitNodeID == p2.ExitNodeID &&
 		p.ExitNodeIP == p2.ExitNodeIP &&
 		p.AutoExitNode == p2.AutoExitNode &&
@@ -738,6 +767,7 @@ func NewPrefs() *Prefs {
 		ControlURL: "",
 
 		CorpDNS:             true,
+		RouteLocal:          false,
 		WantRunning:         false,
 		NetfilterMode:       preftype.NetfilterOn,
 		NoStatefulFiltering: opt.NewBool(true),
diff --git a/net/netcheck/netcheck.go b/net/netcheck/netcheck.go
index ebcdc4eac..7864a37b3 100644
--- a/net/netcheck/netcheck.go
+++ b/net/netcheck/netcheck.go
@@ -1076,7 +1076,11 @@ func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *report
 		go func() {
 			defer wg.Done()
 			node := rg.Nodes[0]
-			req, _ := http.NewRequestWithContext(ctx, "HEAD", "https://"+node.HostName+"/derp/probe", nil)
+			tlsport := 443
+			if node.DERPPort != 0 {
+				tlsport = node.DERPPort
+			}
+			req, _ := http.NewRequestWithContext(ctx, "HEAD", "https://"+node.HostName+":"+fmt.Sprint(tlsport)+"/derp/probe", nil)
 			// One warm-up one to get HTTP connection set
 			// up and get a connection from the browser's
 			// pool.
@@ -1152,11 +1156,11 @@ func (c *Client) measureHTTPSLatency(ctx context.Context, reg *tailcfg.DERPRegio
 		},
 	}
 	hc := &http.Client{Transport: tr}
-
-	// This is the request that will be measured, the request and response
-	// should be small enough to fit into a single packet each way unless the
-	// connection has already become unstable.
-	req, err := http.NewRequestWithContext(ctx, "GET", "https://"+node.HostName+"/derp/latency-check", nil)
+	tlsport := 443
+	if node.DERPPort != 0 {
+		tlsport = node.DERPPort
+	}
+	req, err := http.NewRequestWithContext(ctx, "GET", "https://"+node.HostName+":"+fmt.Sprint(tlsport)+"/derp/latency-check", nil)
 	if err != nil {
 		return 0, ip, err
 	}
@@ -1418,6 +1422,11 @@ func (c *Client) addReportHistoryAndSetPreferredDERP(rs *reportState, r *Report,
 			d = time.Duration(float64(d) * score)
 		}
 
+		if regionID < 0 {
+			// STUNOnly is not readable here
+			// so use negative region IDs to mark stun-only servers
+			continue
+		}
 		if regionID == prevDERP {
 			oldRegionCurLatency = d
 		}
diff --git a/net/netmon/state.go b/net/netmon/state.go
index 10d68ab78..0ef905a39 100644
--- a/net/netmon/state.go
+++ b/net/netmon/state.go
@@ -20,6 +20,7 @@
 	"tailscale.com/hostinfo"
 	"tailscale.com/net/netaddr"
 	"tailscale.com/net/tsaddr"
+	"tailscale.com/syncs"
 	"tailscale.com/util/mak"
 )
 
@@ -35,8 +36,59 @@
 func isUp(nif *net.Interface) bool       { return nif.Flags&net.FlagUp != 0 }
 func isLoopback(nif *net.Interface) bool { return nif.Flags&net.FlagLoopback != 0 }
 
+// ignoredInterfaces stores interface name patterns to ignore (comma-separated).
+// These interfaces will not have their addresses reported to the Tailscale server.
+var ignoredInterfaces struct {
+	mu         syncs.Mutex
+	rawPattern string   // the raw pattern string for change detection
+	patterns   []string // parsed patterns
+}
+
+// SetIgnoredInterfaces sets a list of interface name patterns to ignore.
+// Patterns are matched as prefixes against interface names.
+// For example, "docker0,br-,veth" would ignore docker0, any interface starting
+// with br-, and any interface starting with veth.
+func SetIgnoredInterfaces(patterns string) {
+	ignoredInterfaces.mu.Lock()
+	defer ignoredInterfaces.mu.Unlock()
+	// Skip reprocessing if patterns haven't changed
+	if patterns == ignoredInterfaces.rawPattern {
+		return
+	}
+	ignoredInterfaces.rawPattern = patterns
+	if patterns == "" {
+		ignoredInterfaces.patterns = nil
+		return
+	}
+	parts := strings.Split(patterns, ",")
+	ignoredInterfaces.patterns = make([]string, 0, len(parts))
+	for _, p := range parts {
+		p = strings.TrimSpace(p)
+		if p != "" {
+			ignoredInterfaces.patterns = append(ignoredInterfaces.patterns, p)
+		}
+	}
+}
+
+// isIgnoredInterface reports whether the given interface name matches any
+// of the user-configured ignore patterns.
+func isIgnoredInterface(name string) bool {
+	ignoredInterfaces.mu.Lock()
+	defer ignoredInterfaces.mu.Unlock()
+	for _, pattern := range ignoredInterfaces.patterns {
+		if strings.HasPrefix(name, pattern) {
+			return true
+		}
+	}
+	return false
+}
+
 func isProblematicInterface(nif *net.Interface) bool {
 	name := nif.Name
+	// Check user-configured ignored interfaces first
+	if isIgnoredInterface(name) {
+		return true
+	}
 	// Don't try to send disco/etc packets over zerotier; they effectively
 	// DoS each other by doing traffic amplification, both of them
 	// preferring/trying to use each other for transport. See:
diff --git a/net/tsaddr/tsaddr.go b/net/tsaddr/tsaddr.go
index 1eac9eb77..3fae937cd 100644
--- a/net/tsaddr/tsaddr.go
+++ b/net/tsaddr/tsaddr.go
@@ -26,6 +26,18 @@ func ChromeOSVMRange() netip.Prefix {
 
 var chromeOSRange oncePrefix
 
+func CustomNetRange() netip.Prefix {
+	customNetRange.Do(func() { mustPrefix(&customNetRange.v, "172.22.98.0/24") })
+	return customNetRange.v
+}
+func CustomNet6Range() netip.Prefix {
+	customNet6Range.Do(func() { mustPrefix(&customNet6Range.v, "fd00:3d22:4e98:cafe::/64") })
+	return customNet6Range.v
+}
+
+var customNetRange oncePrefix
+var customNet6Range oncePrefix
+
 // CGNATRange returns the Carrier Grade NAT address range that
 // is the superset range that Tailscale assigns out of.
 // See https://tailscale.com/s/cgnat
@@ -72,13 +84,13 @@ func IsTailscaleIP(ip netip.Addr) bool {
 	if ip.Is4() {
 		return IsTailscaleIPv4(ip)
 	}
-	return TailscaleULARange().Contains(ip)
+	return CustomNet6Range().Contains(ip) || TailscaleULARange().Contains(ip)
 }
 
 // IsTailscaleIPv4 reports whether an IPv4 IP is an IP address that
 // Tailscale assigns from.
 func IsTailscaleIPv4(ip netip.Addr) bool {
-	return CGNATRange().Contains(ip) && !ChromeOSVMRange().Contains(ip)
+	return CustomNetRange().Contains(ip) || (CGNATRange().Contains(ip) && !ChromeOSVMRange().Contains(ip))
 }
 
 // TailscaleULARange returns the IPv6 Unique Local Address range that
diff --git a/types/netmap/netmap.go b/types/netmap/netmap.go
index ac95254da..8bfc7fb0c 100644
--- a/types/netmap/netmap.go
+++ b/types/netmap/netmap.go
@@ -77,6 +77,11 @@ type NetworkMap struct {
 	// UserProfiles contains the profile information of UserIDs referenced
 	// in SelfNode and Peers.
 	UserProfiles map[tailcfg.UserID]tailcfg.UserProfileView
+
+	// IgnoreRoutes is a list of CIDR prefixes to ignore when accepting
+	// routes advertised by other nodes. Routes that overlap with these
+	// prefixes will not be installed.
+	IgnoreRoutes []netip.Prefix
 }
 
 // User returns nm.SelfNode.User if nm.SelfNode is non-nil, otherwise it returns
@@ -468,6 +473,7 @@ func (nm *NetworkMap) JSON() string {
 const (
 	_ WGConfigFlags = 1 << iota
 	AllowSubnetRoutes
+	AllowLocalRoutes
 )
 
 // IPServiceMappings maps IP addresses to service names. This is the inverse of
diff --git a/wgengine/magicsock/derp.go b/wgengine/magicsock/derp.go
index b3cc5c2ce..0cd6d8d03 100644
--- a/wgengine/magicsock/derp.go
+++ b/wgengine/magicsock/derp.go
@@ -280,6 +280,29 @@ func (c *Conn) startDerpHomeConnectLocked() {
 	c.goDerpConnect(c.myDerp)
 }
 
+func (c *Conn) prepareFallbackDERP(ep *endpoint) {
+	if len(ep.endpointState) <= 2 {
+		// derp connected, so the only endpoint is derp
+		onlyderp := true
+		for addr := range ep.endpointState {
+			if addr.Addr() != tailcfg.DerpMagicIPAddr {
+				onlyderp = false
+				break
+			}
+		}
+		if onlyderp {
+			derpid := int(ep.derpAddr.Port())
+			active, ok := c.activeDerp[derpid]
+			if !ok {
+				c.goDerpConnect(derpid)
+				c.logf("magicsock: prepare fallback derp to %v at %v", ep.discoShort, derpid)
+			} else {
+				*active.lastWrite = time.Now()
+			}
+		}
+	}
+}
+
 // goDerpConnect starts a goroutine to start connecting to the given
 // DERP region ID.
 //
diff --git a/wgengine/magicsock/magicsock.go b/wgengine/magicsock/magicsock.go
index b2852d2e2..698643b78 100644
--- a/wgengine/magicsock/magicsock.go
+++ b/wgengine/magicsock/magicsock.go
@@ -2581,6 +2581,26 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {
 		return
 	}
 
+	// Ignore endpoints from isolated peers.
+	if len(de.endpointState) == 0 {
+		// derp not initialized yet, so no endpoints
+		return
+	}
+
+	if len(de.endpointState) <= 2 {
+		// derp connected, so the only endpoint is derp
+		onlyderp := true
+		for addr := range de.endpointState {
+			if addr.Addr() != tailcfg.DerpMagicIPAddr {
+				onlyderp = false
+				break
+			}
+		}
+		if onlyderp {
+			return
+		}
+	}
+
 	if !c.lastEndpointsTime.After(time.Now().Add(-endpointsFreshEnoughDuration)) {
 		c.dlogf("[v1] magicsock: want call-me-maybe but endpoints stale; restunning")
 
@@ -3070,6 +3090,7 @@ func (c *Conn) updateNodes(self tailcfg.NodeView, peers []tailcfg.NodeView) (pee
 				oldDiscoKey = epDisco.key
 			}
 			ep.updateFromNode(n, flags.heartbeatDisabled, flags.probeUDPLifetimeOn)
+			c.prepareFallbackDERP(ep)
 			c.peerMap.upsertEndpoint(ep, oldDiscoKey) // maybe update discokey mappings in peerMap
 			continue
 		}
diff --git a/wgengine/wgcfg/nmcfg/nmcfg.go b/wgengine/wgcfg/nmcfg/nmcfg.go
index f99b7b007..2bea10cad 100644
--- a/wgengine/wgcfg/nmcfg/nmcfg.go
+++ b/wgengine/wgcfg/nmcfg/nmcfg.go
@@ -101,6 +101,10 @@ func WGCfg(pk key.NodePrivate, nm *netmap.NetworkMap, logf logger.Logf, flags ne
 		cpeer.V4MasqAddr = peer.SelfNodeV4MasqAddrForThisPeer().Clone()
 		cpeer.V6MasqAddr = peer.SelfNodeV6MasqAddrForThisPeer().Clone()
 		cpeer.IsJailed = peer.IsJailed()
+		var localIps []netip.Addr
+		for _, ep := range nm.SelfNode.Endpoints().All() {
+			localIps = append(localIps, ep.Addr())
+		}
 		for _, allowedIP := range peer.AllowedIPs().All() {
 			if allowedIP.Bits() == 0 && peer.StableID() != exitNode {
 				if didExitNodeLog {
@@ -114,9 +118,29 @@ func WGCfg(pk key.NodePrivate, nm *netmap.NetworkMap, logf logger.Logf, flags ne
 				if (flags & netmap.AllowSubnetRoutes) == 0 {
 					skippedSubnetRouter = append(skippedSubnetRouter, peer)
 					continue
+				} else if (flags & netmap.AllowLocalRoutes) == 0 {
+					ignoreRoute := false
+					for _, localIP := range localIps {
+						if allowedIP.Contains(localIP) {
+							ignoreRoute = true
+							break
+						}
+					}
+					if ignoreRoute {
+						logf("[v1] wgcfg: skipping local subnet route %v from %q (%v)", allowedIP, nodeDebugName(peer), peer.Key().ShortString())
+						continue
+					}
+				}
+				// Check against user-defined ignore routes
+				for _, ignorePrefix := range nm.IgnoreRoutes {
+					if allowedIP.Overlaps(ignorePrefix) {
+						logf("[v1] wgcfg: skipping ignored route %v (matches %v) from %q (%v)", allowedIP, ignorePrefix, nodeDebugName(peer), peer.Key().ShortString())
+						goto nextAllowedIP
+					}
 				}
 			}
 			cpeer.AllowedIPs = append(cpeer.AllowedIPs, allowedIP)
+		nextAllowedIP:
 		}
 	}
 
-- 
2.52.0

