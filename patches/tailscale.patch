diff --git a/go.mod b/go.mod
index d0dfe03c..adcaf248 100644
--- a/go.mod
+++ b/go.mod
@@ -2,6 +2,8 @@ module tailscale.com
 
 go 1.20
 
+replace github.com/tailscale/wireguard-go => ../wireguard-go
+
 require (
 	filippo.io/mkcert v1.4.3
 	github.com/Microsoft/go-winio v0.6.0
diff --git a/net/netcheck/netcheck.go b/net/netcheck/netcheck.go
index 687aa6a8..5ff33843 100644
--- a/net/netcheck/netcheck.go
+++ b/net/netcheck/netcheck.go
@@ -1118,7 +1118,7 @@ func (c *Client) checkCaptivePortal(ctx context.Context, dm *tailcfg.DERPMap, pr
 		(preferredDERP != 0 && len(dm.Regions[preferredDERP].Nodes) == 0) {
 		rids := make([]int, 0, len(dm.Regions))
 		for id, reg := range dm.Regions {
-			if reg == nil || reg.Avoid || len(reg.Nodes) == 0 {
+			if reg == nil || reg.Avoid || len(reg.Nodes) == 0 || reg.Nodes[0].DERPPort != 0 {
 				continue
 			}
 			rids = append(rids, id)
@@ -1137,8 +1137,11 @@ func (c *Client) checkCaptivePortal(ctx context.Context, dm *tailcfg.DERPMap, pr
 		// TODO(bradfitz,andrew-d): how to actually handle this nicely?
 		return false, nil
 	}
-
-	req, err := http.NewRequestWithContext(ctx, "GET", "http://"+node.HostName+"/generate_204", nil)
+	httpport := 80
+	if node.DERPPort != 0 {
+		httpport = node.DERPPort
+	}
+	req, err := http.NewRequestWithContext(ctx, "GET", "http://"+node.HostName+":"+fmt.Sprint(httpport)+"/generate_204", nil)
 	if err != nil {
 		return false, err
 	}
@@ -1189,7 +1192,11 @@ func (c *Client) runHTTPOnlyChecks(ctx context.Context, last *Report, rs *report
 		go func() {
 			defer wg.Done()
 			node := rg.Nodes[0]
-			req, _ := http.NewRequestWithContext(ctx, "HEAD", "https://"+node.HostName+"/derp/probe", nil)
+			tlsport := 443
+			if node.DERPPort != 0 {
+				tlsport = node.DERPPort
+			}
+			req, _ := http.NewRequestWithContext(ctx, "HEAD", "https://"+node.HostName+":"+fmt.Sprint(tlsport)+"/derp/probe", nil)
 			// One warm-up one to get HTTP connection set
 			// up and get a connection from the browser's
 			// pool.
@@ -1260,8 +1267,11 @@ func (c *Client) measureHTTPSLatency(ctx context.Context, reg *tailcfg.DERPRegio
 		},
 	}
 	hc := &http.Client{Transport: tr}
-
-	req, err := http.NewRequestWithContext(ctx, "GET", "https://"+node.HostName+"/derp/latency-check", nil)
+	tlsport := 443
+	if node.DERPPort != 0 {
+		tlsport = node.DERPPort
+	}
+	req, err := http.NewRequestWithContext(ctx, "GET", "https://"+node.HostName+":"+fmt.Sprint(tlsport)+"/derp/latency-check", nil)
 	if err != nil {
 		return 0, ip, err
 	}
@@ -1460,6 +1470,11 @@ func (c *Client) addReportHistoryAndSetPreferredDERP(r *Report) {
 	var bestAny time.Duration
 	var oldRegionCurLatency time.Duration
 	for regionID, d := range r.RegionLatency {
+		if regionID < 0 {
+			// STUNOnly is not readable here
+			// so use negative region IDs to mark stun-only servers
+			continue
+		}
 		if regionID == prevDERP {
 			oldRegionCurLatency = d
 		}
diff --git a/net/tsaddr/tsaddr.go b/net/tsaddr/tsaddr.go
index 34259b69..788df2bf 100644
--- a/net/tsaddr/tsaddr.go
+++ b/net/tsaddr/tsaddr.go
@@ -24,6 +24,18 @@ func ChromeOSVMRange() netip.Prefix {
 
 var chromeOSRange oncePrefix
 
+func CustomNetRange() netip.Prefix {
+	customNetRange.Do(func() { mustPrefix(&customNetRange.v, "172.22.98.0/24") })
+	return customNetRange.v
+}
+func CustomNet6Range() netip.Prefix {
+	customNet6Range.Do(func() { mustPrefix(&customNet6Range.v, "fd00:3d22:4e98:cafe::/64") })
+	return customNet6Range.v
+}
+
+var customNetRange oncePrefix
+var customNet6Range oncePrefix
+
 // CGNATRange returns the Carrier Grade NAT address range that
 // is the superset range that Tailscale assigns out of.
 // See https://tailscale.com/s/cgnat
@@ -69,9 +81,9 @@ func TailscaleServiceIPv6() netip.Addr {
 // Tailscale assigns from.
 func IsTailscaleIP(ip netip.Addr) bool {
 	if ip.Is4() {
-		return CGNATRange().Contains(ip) && !ChromeOSVMRange().Contains(ip)
+		return CustomNetRange().Contains(ip) || (CGNATRange().Contains(ip) && !ChromeOSVMRange().Contains(ip))
 	}
-	return TailscaleULARange().Contains(ip)
+	return CustomNet6Range().Contains(ip) || TailscaleULARange().Contains(ip)
 }
 
 // TailscaleULARange returns the IPv6 Unique Local Address range that
diff --git a/wgengine/magicsock/magicsock.go b/wgengine/magicsock/magicsock.go
index 8374193d..d0c651d8 100644
--- a/wgengine/magicsock/magicsock.go
+++ b/wgengine/magicsock/magicsock.go
@@ -1110,6 +1110,29 @@ func (c *Conn) startDerpHomeConnectLocked() {
 	c.goDerpConnect(c.myDerp)
 }
 
+func (c *Conn) prepareFallbackDERP(ep *endpoint) {
+	if len(ep.endpointState) <= 2 {
+		// derp connected, so the only endpoint is derp
+		onlyderp := true
+		for addr := range ep.endpointState {
+			if addr.Addr() != derpMagicIPAddr {
+				onlyderp = false
+				break
+			}
+		}
+		if onlyderp {
+			derpid := int(ep.derpAddr.Port())
+			active, ok := c.activeDerp[derpid]
+			if !ok {
+				c.goDerpConnect(derpid)
+				c.logf("magicsock: prepare fallback derp to %v at %v", ep.discoShort, derpid)
+			} else {
+				*active.lastWrite = time.Now()
+			}
+		}
+	}
+}
+
 // goDerpConnect starts a goroutine to start connecting to the given
 // DERP node.
 //
@@ -2432,6 +2455,26 @@ func (c *Conn) enqueueCallMeMaybe(derpAddr netip.AddrPort, de *endpoint) {
 		return
 	}
 
+	// Ignore endpoints from isolated peers.
+	if len(de.endpointState) == 0 {
+		// derp not initialized yet, so	no endpoints
+		return
+	}
+
+	if len(de.endpointState) <= 2 {
+		// derp connected, so the only endpoint is derp
+		onlyderp := true
+		for addr := range de.endpointState {
+			if addr.Addr() != derpMagicIPAddr {
+				onlyderp = false
+				break
+			}
+		}
+		if onlyderp {
+			return
+		}
+	}
+
 	eps := make([]netip.AddrPort, 0, len(c.lastEndpoints))
 	for _, ep := range c.lastEndpoints {
 		eps = append(eps, ep.Addr)
@@ -2728,6 +2771,7 @@ func (c *Conn) SetNetworkMap(nm *netmap.NetworkMap) {
 				oldDiscoKey = epDisco.key
 			}
 			ep.updateFromNode(n, heartbeatDisabled)
+			c.prepareFallbackDERP(ep)
 			c.peerMap.upsertEndpoint(ep, oldDiscoKey) // maybe update discokey mappings in peerMap
 			continue
 		}
@@ -4138,7 +4182,7 @@ type pendingCLIPing struct {
 
 	// derpInactiveCleanupTime is how long a non-home DERP connection
 	// needs to be idle (last written to) before we close it.
-	derpInactiveCleanupTime = 60 * time.Second
+	derpInactiveCleanupTime = 180 * time.Second
 
 	// derpCleanStaleInterval is how often cleanStaleDerp runs when there
 	// are potentially-stale DERP connections to close.
@@ -4922,6 +4966,34 @@ func (de *endpoint) handleCallMeMaybe(m *disco.CallMeMaybe) {
 		// Nothing to do on js/wasm if we can't send UDP packets anyway.
 		return
 	}
+	// Ignore endpoints from isolated peers.
+	if len(de.endpointState) == 0 {
+		// derp not initialized yet, so	no endpoints
+		de.debugUpdates.Add(EndpointChange{
+			When: time.Now(),
+			What: "handleCallMeMaybe-isolated-0-ep",
+			To:   m.MyNumber,
+		})
+		return
+	}
+	if len(de.endpointState) <= 2 {
+		// derp connected, so the only endpoint is derp
+		onlyderp := true
+		for addr := range de.endpointState {
+			if addr.Addr() != derpMagicIPAddr {
+				onlyderp = false
+				break
+			}
+		}
+		if onlyderp {
+			de.debugUpdates.Add(EndpointChange{
+				When: time.Now(),
+				What: "handleCallMeMaybe-isolated-derp-only",
+				To:   m.MyNumber,
+			})
+			return
+		}
+	}
 	de.mu.Lock()
 	defer de.mu.Unlock()
 
@@ -4929,6 +5001,10 @@ func (de *endpoint) handleCallMeMaybe(m *disco.CallMeMaybe) {
 	for ep := range de.isCallMeMaybeEP {
 		de.isCallMeMaybeEP[ep] = false // mark for deletion
 	}
+	var currentEPs []netip.AddrPort
+	for ep := range de.endpointState {
+		currentEPs = append(currentEPs, ep)
+	}
 	var newEPs []netip.AddrPort
 	for _, ep := range m.MyNumber {
 		if ep.Addr().Is6() && ep.Addr().IsLinkLocalUnicast() {
@@ -4946,6 +5022,11 @@ func (de *endpoint) handleCallMeMaybe(m *disco.CallMeMaybe) {
 		}
 	}
 	if len(newEPs) > 0 {
+		de.debugUpdates.Add(EndpointChange{
+			When: time.Now(),
+			What: "handleCallMeMaybe-old-endpoints",
+			To:   currentEPs,
+		})
 		de.debugUpdates.Add(EndpointChange{
 			When: time.Now(),
 			What: "handleCallMeMaybe-new-endpoints",
diff --git a/wgengine/wgcfg/nmcfg/nmcfg.go b/wgengine/wgcfg/nmcfg/nmcfg.go
index f01b42cb..8ae03de1 100644
--- a/wgengine/wgcfg/nmcfg/nmcfg.go
+++ b/wgengine/wgcfg/nmcfg/nmcfg.go
@@ -102,6 +102,17 @@ func WGCfg(nm *netmap.NetworkMap, logf logger.Logf, flags netmap.WGConfigFlags,
 
 		didExitNodeWarn := false
 		cpeer.V4MasqAddr = peer.SelfNodeV4MasqAddrForThisPeer
+		var localIps []netip.Addr
+		if nm.SelfNode != nil {
+			for _, ep := range nm.SelfNode.Endpoints {
+				addr, err := netip.ParseAddrPort(ep)
+				if err == nil {
+					localIps = append(localIps, addr.Addr())
+				} else {
+					logf("[v1] wgcfg: unable to parse endpoint %q: %v", ep, err)
+				}
+			}
+		}
 		for _, allowedIP := range peer.AllowedIPs {
 			if allowedIP.Bits() == 0 && peer.StableID != exitNode {
 				if didExitNodeWarn {
@@ -127,6 +138,21 @@ func WGCfg(nm *netmap.NetworkMap, logf logger.Logf, flags netmap.WGConfigFlags,
 					}
 					fmt.Fprintf(skippedSubnets, "%v from %q (%v)", allowedIP, nodeDebugName(peer), peer.Key.ShortString())
 					continue
+				} else {
+					ignoreRoute := false
+					for _, localIP := range localIps {
+						if allowedIP.Contains(localIP) {
+							ignoreRoute = true
+							break
+						}
+					}
+					if ignoreRoute {
+						if skippedSubnets.Len() > 0 {
+							skippedSubnets.WriteString(", ")
+						}
+						fmt.Fprintf(skippedSubnets, "%v (localip) from %q (%v)", allowedIP, nodeDebugName(peer), peer.Key.ShortString())
+						continue
+					}
 				}
 			}
 			cpeer.AllowedIPs = append(cpeer.AllowedIPs, allowedIP)
